# If not running interactively, don't do anything
# ###############################################

[[ $- != *i* ]] && return

# Uncomment to enable debugging mode/no tmux
# ##########################################
# DEBUG=1
# NO_TMUX=1

# Setup PATH so we can find bins
# ##############################
LOCAL_BIN=~/.local/bin
WINDOWS_BIN=/mnt/c/bin
if [[ $(uname -r)] == ^*Microsoft$ ]]; then
  PATH="$WINDOWS_BIN:$PATH"
elif [[ "$OSTYPE" == "darwin"* ]]; then
  PATH="/usr/local/bin/:$PATH"
  [[ -x /usr/libexec/java_home ]] && /usr/libexec/java_home &>/dev/null && export JAVA_HOME=`/usr/libexec/java_home`
fi
export PATH="$LOCAL_BIN:$PATH"

# Daemon Autostart on WSL
#########################

WSL_EXE=/mnt/c/Windows/System32/wsl.exe

function is_wsl_v2() {
  # check that WSL exe and distro name exists
  ( [ -x "$WSL_EXE" ] && [ -n "$WSL_DISTRO_NAME" ] ) || return 1
  # build filter pattern
  filter='^[ *] '"$WSL_DISTRO_NAME"' *(Running|Stopped) *2\r$'
  # check for match:
  # 0. set fail on error
  # 1. run wsl.exe -l -v
  # 2. convert to UTF-8
  # 3. strip first line
  # 4. match regex
  ( set -euo pipefail && "$WSL_EXE" -l -v | iconv -f UTF-16 -t UTF-8 | tail -n +2 | grep -P "$filter" &>/dev/null )
}

function daemon_needs_start() {
  which "$1" &>/dev/null && ! pgrep -U0 -x "$1" &>/dev/null ;
}

# WSLv2 Daemon Management (requires nopasswd sudo for running daemons using default user)
if is_wsl_v2; then
  if daemon_needs_start dockerd; then
    DOCKER_DIR=/mnt/wsl/shared-docker
    mkdir -pm o=,ug=rwx "$DOCKER_DIR" \
    && chgrp docker "$DOCKER_DIR" \
    && "$WSL_EXE" -d $WSL_DISTRO_NAME sh -c "nohup sudo -b dockerd < /dev/null > $DOCKER_DIR/dockerd.log 2>&1"
  fi
  if daemon_needs_start nix-daemon; then
    "$WSL_EXE" -d $WSL_DISTRO_NAME sh -c "nohup sudo -b nix-daemon < /dev/null > /dev/null 2>&1"
  fi
fi

# TMUX session Autostart
# ######################

STANDARD_TERM=false
[ -z $DEBUG ] && [ $TERM != "linux" ] && [ -z $INSIDE_EMACS ] && [ -z $VSCODE_IPC_HOOK_CLI ] && STANDARD_TERM=true

# startup tmux unless we don't need to
if $STANDARD_TERM && [ -z $NO_TMUX ] && [ -z $TMUX ] && [ -x "$(command -v tmux)" ]; then
  # pretend we are xterm
  export TERM=xterm-256color
  # clear the terminal title
  echo -ne "\033]0;\007"
  # start the session/session group
  if [ -z "$SSH_CLIENT" ]; then
    # startup ding-server if needed
    export DING_PORT=$(~/.config/meta/ding-init)
    ~/.config/meta/ding-server &

    # abort if a session already exists
    tmux_group="main"
    if tmux list-sessions -F "#{session_group}" 2>/dev/null | grep "^$tmux_group" 1>/dev/null 2>/dev/null; then
      echo "=================================="
      echo "Existing session found. Exiting..."
      echo "=================================="
      sleep 5
      exit
    fi

    # no session exists, open new session
    exec tmux -f ~/.config/tmux/tmux.conf new-session -t "$tmux_group" \; set-option destroy-unattached
  else
    # here, if we open multiple instances, they all run identically (don't want to accidentally leave sessions open on the server)
    exec tmux -f ~/.config/tmux/tmux.conf new-session -A -s remote
  fi
fi

# initialize pretty shell colors (when in a compatible terminal)
# ##############################################################

function load_colors() {
  BASE16_SHELL="$HOME/.config/shell/theme/base16-shell/"
  [ -n "$PS1" ] && \
      [ -s "$BASE16_SHELL/profile_helper.sh" ] && \
          source "$BASE16_SHELL/profile_helper.sh"
}

function _color_tmux() {
  tmux_needs_color=$1
  colorfile=$2
  if [ -n $TMUX ] && ($tmux_needs_color || ! $TMUX_COLOR_APPLIED) && [ -f "$colorfile" ] ; then
    tmux source-file "$colorfile"
    tmux set-environment -g TMUX_COLOR_APPLIED true
    export TMUX_COLOR_APPLIED=true
  fi
  unset tmux_needs_color
  unset colorfile
}

function color_shell() {
  ! $STANDARD_TERM && return 1
  tmux_needs_color=false
  theme_link="$HOME/.base16_theme"
  theme_vim="$HOME/.base16_vim"
  if [ $# -eq 0 ]; then
    [ ! -L "$theme_link" ] && echo "no theme found" && return 1
    source "$theme_link"
  else
    theme=$1
    shell_theme_file="$HOME/.config/shell/theme/base16-shell/scripts/base16-$theme.sh"
    if [ -f "$shell_theme_file" ]; then
      source "$shell_theme_file"
      ln -sf "$shell_theme_file" "$theme_link"
      echo "base16-$BASE16_THEME" > "$theme_vim"
      tmux_needs_color=true
    else
      echo "base16 theme $theme not found"
      return 1
    fi
  fi
  _color_tmux $tmux_needs_color "$HOME/.config/tmux/plugins/base16-tmux/colors/base16-$theme.conf"
  unset nocolor_tmux
  unset theme_link
}

if $STANDARD_TERM; then
  # disable software control flow terminal shortcuts ctrl+S/ctrl+Q
  # but allow internal libraries to use this mechanism if they wish
  stty -ixon <$TTY >$TTY

  # handle colors
  color_shell

  # set dircolors
  if [ -e "$HOME/.config/dircolors/dircolors" ] ; then
    eval "$(dircolors -b $HOME/.config/dircolors/dircolors)"
  fi

  # shell specific stuff
  if [ "$BASH_VERSION" ]; then
    # setup fancy prompt
    # slow on DrvFS
    source ~/.config/shell/minimalist-git-prompt.sh
    # PS1="\W \\$ "

  elif [ "$ZSH_VERSION" ]; then
    # force cursor blink
    echo -e -n "\x1b[\x31 q"

    # Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
    # Initialization code that may require console input (password prompts, [y/n]
    # confirmations, etc.) must go above this block; everything else may go below.
    if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
      source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
    fi

    # load powerlevel10k
    source ~/.config/shell/theme/zsh/powerlevel10k/powerlevel10k.zsh-theme
    source ~/.config/shell/theme/zsh/powerlevel10k-config.zsh
  fi
else
  PS1="\W \\$ "
  PROMPT="%1~ %(!.#.$) "
fi

# Initialize shell keybindings
# ############################

if [ "$BASH_VERSION" ]; then
  # load fzf bindings (only makes sense under readline)
  source ~/.config/shell/fzf/completion.bash
  source ~/.config/shell/fzf/key-bindings.bash
elif [ "$ZSH_VERSION" ]; then
  # set vi-mode
  bindkey -v

  # enable completion for git and vbox
  zstyle ':completion:*:*:git:*' script ~/.config/shell/bash/git-completion.bash
  fpath=(~/.config/shell/zsh $fpath)
  autoload -U +X compinit && compinit
  autoload -U +X bashcompinit && bashcompinit
  source ~/.config/shell/bash/vboxmanage-bash-completion/VBoxManage

  # make nice commandline search work
  autoload -U history-search-end
  zle -N history-beginning-search-backward-end history-search-end
  zle -N history-beginning-search-forward-end history-search-end
  bindkey -M emacs "^[[A" history-beginning-search-backward-end
  bindkey -M emacs "^[[B" history-beginning-search-forward-end
  bindkey -M viins "^[[A" history-beginning-search-backward-end
  bindkey -M viins "^[[B" history-beginning-search-forward-end
fi

# Setup our environment and aliases
# #################################

export EDITOR=nvim
export XDG_CONFIG_HOME=~/.config
export XDG_CACHE_HOME=~/.cache
export XDG_DATA_HOME=~/.local/share
export JUPYTER_CONFIG_DIR=$XDG_CONFIG_HOME/jupyter
export LESS="-FRXK"
[ -z "$BASH_VERSION" ] || export EXECIGNORE="$EXECIGNORE:*dll"
[ -z "$ZSH_VERSION"  ] || export fignore=(dll $fignore)

# Setup history for bash/zsh
export HISTFILE="$XDG_CACHE_HOME/shell_history"
export HISTSIZE=10000
export SAVEHIST=10000
export HISTCONTROL=ignoredups
[ -z "$ZSH_VERSION" ] || { setopt -h ; setopt HIST_IGNORE_DUPS ; }
if [ ! -f "$HISTFILE" ]; then
  touch "$HISTFILE"
fi

# do extra setup on remote sessions
if [ -n "$SSH_CLIENT" ]; then
  # do not ask for passwords via guis
  unset SSH_ASKPASS
  export GIT_ASKPASS=
  # let's be explicit about logging out
  export IGNOREEOF=5
fi

# fix delete key on mac (must be combined with terminal app mapping delete key to same code)
[[ "$OSTYPE" != "darwin"* ]] || [[ -n $TMUX ]] || stty erase '^?'
# fix locale on OSX
[[ "$OSTYPE" != "darwin"* ]] || export LANG="en_US.UTF-8"

# setup functions/aliases after defining environment
alias wget="wget --hsts-file=\"$XDG_CACHE_HOME/wget-hsts\""
# alias ls='exa ' # let's wait until the bugs are worked out more
if [[ "$OSTYPE" != "darwin"* ]]; then
  alias ls='ls --color=auto'
else
  export CLICOLOR=1
fi
alias sl='ls'
alias vi='nvim '
alias vim='nvim '
alias python='python3 '
alias claer='clear '
alias pypy='pypy3 '
alias diff='git diff --color-moved=blocks --no-index'
alias g='git '
# alias mux="PATH=$SAFEPATH tmuxinator "

# create new github repo
function ghrepo() { curl -u 'skeirik2' https://api.github.com/user/repos -d '{"name":"$1"}'; }

# find maude modules defined in code in given subdirectory
function mmods() { rg "^\S*^f?mod" * | cut -d' ' -f2; }

# look-up files in a git repo with ext respecting ignore
function fbe() { rg --files -g '*'"$1"; }

# tmux session shortcut from Everett
function ts() {
    command="$1" ; shift
    session="$1"
    case "$command" in
        n|new)    tmux new-session -s "$session" ;;
        a|attach) [ "$session" == "" ] && { echo "Usage: ts attach <session>"; return 1; } || tmux attach -t "$session" ;;
        d|detach) tmux detach;;
        k|kill)   [ "$session" == "" ] && { echo "Usage: ts kill <session>"; return 1; } || tmux kill-session  -t "$session" ;;
        l|ls)     tmux list-sessions ;;
        '')       tmux list-sessions ;;
        *)        echo "Unrecognized 'ts' command: '$command'" >&2
                  return 1 ;;
    esac
}

# start up jupyter notebook
function jnb() {
  NB_DIR=~/.local/share/jupyter/notebooks
  (source ~/.venv/jupyter/bin/activate && mkdir -p "$NB_DIR" && jupyter notebook --notebook-dir "$NB_DIR")
}

# setx wrapper for setting environment variables
# function setx() {
# TODO: finish me
# }

# set os light-dark theme
function sunrise() {
  is_wsl_v2 && _win_lightmode true
  color_shell google-light
}

function sunset() {
  is_wsl_v2 && _win_lightmode false
  color_shell gruvbox-dark-hard
}

# Setup WSL-specific Functions
# ############################

alias powershell="/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe"

# set os mode to light or dark
function _win_lightmode() {
  case "$1" in
    true)  light=1 ;;
    false) light=0 ;;
    *)     echo "usage: win_lightmode <true|false>" && return 1 ;;
  esac
  (powershell -Command\
  "Start-Transaction;"\
  "Set-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize -Name AppsUseLightTheme    -Value $light -Type Dword -Force -UseTransaction;"\
  "Set-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize -Name SystemUsesLightTheme -Value $light -Type Dword -Force -UseTransaction;"\
  "Complete-Transaction" >/dev/null 2>&1 &)
}

# run a command with elevated permissions
function win_elevate() {
    pushd $(pwd)
    cd /mnt/c/
    powershell -Command "Start-Process cmd -ArgumentList  \"/c\",\"$1 2>&1\" -Verb RunAs"
    popd
}

# open a file
if [[ "$OSTYPE" != "darwin"* ]]; then
  function win_open() { /mnt/c/Windows/explorer.exe $1; }
fi
